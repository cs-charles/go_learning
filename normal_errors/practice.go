package normal_errors

/**
永远不要使用形如 var p*a 声明变量，这会混淆指针声明和乘法运算（参考 4.9 小节）
永远不要在 for 循环自身中改变计数器变量（参考 5.4 小节）
永远不要在 for-range 循环中使用一个值去改变自身的值（参考 5.4.4 小节）
永远不要将 goto 和前置标签一起使用（参考 5.6 小节）
永远不要忘记在函数名（参考第 6 章）后加括号 ()，尤其调用一个对象的方法或者使用匿名函数启动一个协程时
永远不要使用 new() 一个 map，一直使用 make（参考第 8 章）
当为一个类型定义一个 String () 方法时，不要使用 fmt.Print 或者类似的代码（参考 10.7 小节）
永远不要忘记当终止缓存写入时，使用 Flush 函数（参考 12.2.3 小节）
永远不要忽略错误提示，忽略错误会导致程序奔溃（参考 13.1 小节）
不要使用全局变量或者共享内存，这会使并发执行的代码变得不安全（参考 14.1 小节）
println 函数仅仅是用于调试的目的
最佳实践：对比以下使用方式：

使用正确的方式初始化一个元素是切片的映射，例如 map[type]slice（参考 8.1.3 小节）
一直使用逗号，ok 或者 checked 形式作为类型断言（参考 11.3 小节）
使用一个工厂函数创建并初始化自己定义类型（参考 10.2 小节 -18.4 小节）
仅当一个结构体的方法想改变结构体时，使用结构体指针作为方法的接受者，否则使用一个结构体值类型

————————————————
原文作者：Go &#25216;&#26415;&#35770;&#22363;&#25991;&#26723;&#65306;&#12298;Go &#20837;&#38376;&#25351;&#21335;&#65288;&#65289;&#12299;
转自链接：https://learnku.com/docs/the-way-to-go/chapter-description/3715
*/

/**
  误用短声明导致变量被覆盖
  采用bytes.Buffer代替字符串操作,将字符串的内容写入到缓冲中

*/

/**
defer 仅在函数返回时才会执行，在循环的结尾或其他一些有限范围的代码内不会执行。
for _, file := range files {
    if f, err = os.Open(file); err != nil {
        return
    }
    // 对文件进行操作
    f.Process(data)
    // 关闭文件
    f.Close()
 }
*/

/**
不需要将一个指向切片的指针传递给函数,因为切片本身就是一个指向数组的指针
   func findBiggest( listOfNumbers []int ) int {}
*/

/**
永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。
*/
/*type nexter interface {
	next() byte
}
func nextFew1(n nexter, num int) []byte {
	var b []byte
	for i:=0; i < num; i++ {
		b[i] = n.next()
	}
	return b
}
func nextFew2(n *nexter, num int) []byte {
	var b []byte
	for i:=0; i < num; i++ {
		b[i] = n.next() // 编译错误:n.next未定义（*nexter类型没有next成员或next方法）
	}
	return b
}
*/

/**
将一个值类型作为一个参数传递给函数或者作为一个方法的接收者，似乎是对内存的滥用，因为值类型一直是传递拷贝。
但是另一方面，值类型的内存是在栈上分配，内存分配快速且开销不大。如果你传递一个指针，而不是一个值类型，
go 编译器大多数情况下会认为需要创建一个对象，并将对象移动到堆上，所以会导致额外的内存分配：
因此当使用指针代替值类型作为参数传递时，我们没有任何收获。

所以值类型大多数情况采用传值，引用类型采用传指针
*/

/**
 闭包与协程一起使用时要注意传值的问题
// 版本C: 正确的处理方式
    for ix := range values {
		//不能直接在闭包内使用ix，否则只能输出values的最大索引下标
        go func(ix interface{}) {
            fmt.Print(ix, " ")
        }(ix)
    }
    fmt.Println()
    time.Sleep(5e9)
    // 版本D: 输出值:
    for ix := range values {
        val := values[ix]
        go func() {
            fmt.Print(val, " ")
        }()
    }
*/
