package goroutine_package

//不要通过共享内存来通信，而通过通信来共享内存。

//不要使用全局变量或者共享内存，它们会给你的代码在并发运算的时候带来危险。

//Go 更倾向于其他的方式，在诸多比较合适的范式中，有个被称作 Communicating Sequential Processes（顺序通信处理）（CSP, C. Hoare 发明的）
//还有一个叫做 message passing-model（消息传递）（已经运用在了其他语言中，比如 Erlang）。

//在协程和操作系统线程之间并无一对一的关系：协程是根据一个或多个线程的可用性，映射（多路复用，执行于）在他们之上的；
//协程调度器在 Go 运行时很好的完成了这个工作。

//不要使用全局变量或者共享内存，它们会给你的代码在并发运算的时候带来危险。

//协程工作在相同的地址空间中，所以共享内存的方式一定是同步的；
//这个可以使用 sync 包来实现（参见第 9.3 节），不过我们很不鼓励这样做：Go 使用 channels 来同步协程

//当系统调用（比如等待 I/O）阻塞协程时，其他协程会继续在其他线程上工作。
//协程的设计隐藏了许多线程创建和管理方面的复杂工作。

//协程的栈会根据需要进行伸缩，不会出现栈溢出；开发者无需关心栈的大小。当协程结束的时候，它会静默退出：用来启动这个协程的函数也不会得到任何的返回值。

//任何 Go 程序都必须有的 main() 函数也可以看做是一个协程，
//尽管它并没有通过 go 来启动。协程可以在程序初始化的过程中运行（在 init() 函数中）。

//GOMAXPROCS
//为了使你的程序可以使用多个核心运行，这时协程就真正的是并行运行了，你必须使用 GOMAXPROCS 变量。
//这会告诉运行时有多少个协程同时执行。
//在 gc 编译器下（6g 或者 8g）你必须设置 GOMAXPROCS 为一个大于默认值 1 的数值来允许运行时支持使用多于 1 个的操作系统线程，否则所有的协程都会共享同一个线程。
//当 GOMAXPROCS 大于 1 时，会有一个线程池管理众多线程。gccgo 编译器 会使 GOMAXPROCS 与运行中的协程数量相等。假设一个机器上有 n 个处理器或者核心。如果你设置环境变量 GOMAXPROCS>=n，或者执行 runtime.GOMAXPROCS(n)，那么协程会被分割（或分散）到 n 个处理器上。但是增加处理器数量并不意味着性能的线性提升。通常，如果有 n 个核心，会设置 GOMAXPROCS 为 n-1 以获得最佳性能，但同样也需要保证，协程的数量 > 1 + GOMAXPROCS > 1

//所以如果在某一时间只有一个协程在执行，不要设置 GOMAXPROCS
//总结：GOMAXPROCS 等同于（并发的）线程数量，在一台核心数多于 1 个的机器上，会尽可能有等同于核心数的线程在并行运行。

//设置GOMAXPROCS数目
//runtime.GOMAXPROCS(n)

//协程可以通过调用 runtime.Goexit() 来停止

//协程是独立的处理单元，一旦陆续启动一些协程，你无法确定他们是什么时候真正开始执行的。你的代码逻辑必须独立于协程调用的顺序。

//Go 协程（goroutines）和协程（coroutines）

//在其他语言中，比如 C#，Lua 或者 Python 都有协程的概念。这个名字表明它和 Go 协程有些相似，不过有两点不同：
//
//Go 协程意味着并行（或者可以以并行的方式部署），协程一般来说不是这样的
//Go 协程通过通道来通信；协程通过让出和恢复操作来通信
//Go 协程比协程更强大，也很容易从协程的逻辑复用到 Go 协程。
